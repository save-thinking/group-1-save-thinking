<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: account.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: account.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** Domain Service - Accounts
 @module domain/account
 */
//  This processing js will act as an adapter between th view layer and storage layer of the app for new account creations.
//  First, it checks that the information given from the View Layer is correct. If it is incorrect we throw a validation error.
//  Second, if validation passes, we pass the new account information to the database where it saves this account and assigns it a database key.
//  Third, if there was a problem storing the information, the database will throw a storing error. We will communicate this error to the user to reattempt the account creation.
//  Fourth, if there were no validation/storage errors then the account must have been added correctly, so we pass this new account info, with its associated key, back to the view layer.
import * as accountStore from "../storage/account.js";
import {
  MissingFieldError,
  FormattingError,
  InvalidAmountError,
} from "./exceptions.js";

const FUND_EMOJI = {
  "checking-account": "🏦",
  "savings-account": "🏥",
  "credit-card": "💳",
  cash: "💸",
};

// /**
//  * Our input is the data given from the New Account fields on the view layer. The input has the form:
// const passedInfo = {"name":"test account name","account_type":"checking-account","initial_balance":"12345","currency":"USD"}

// First this function checks that the given JSON file has a valid amount, non-empty and a positive number.
// If it doesn't, the validateNewAccount function will throw a Validation Error.
// If it successfully validates, then we proceed to give the input to the storage layer.
// If there is a problem in storage, then the addAccountInTable function will throw a Storage Error.
// If we have no errors, then addAccountInTable() will return the newly added account with its key, in JSON format, which we then return.
// */
/**
 * An Account
 * @typedef {Object} Account
 * @property {string} id - Autogenerated ID
 * @property {date} created_at - Created Timestamp
 * @property {date} updated_at - Updated Timestamp
 * @property {string} source - Source of Account (USER)
 * @property {string} emoji - Account Emoji
 * @property {number} initial_balance - Initial Balance
 * @property {number} current_balance - Current Balance
 * @property {string} currency - Currency
 */
/**
 * Validates input and calls Storage Service
 * @public
 * @function addAccount
 *
 * @param {Account} account
 * @returns {Account}
 */

export async function addAccount(account) {
  validateNewAccount(account);
  account.source = "USER";
  account.emoji = FUND_EMOJI[account.type];
  account.initial_balance = Number(account.initial_balance);
  account.current_balance = account.initial_balance;
  return await accountStore.storeAccount(account); // This function comes from the storage layer. Needs to be imported.
  // broadcast new record to all peers would be added here.
}

/**
 * Get all accounts
 * @function getAllUserAccounts
 * @returns {Array.Account}
 */
export async function getAllUserAccounts() {
  const accounts = await accountStore
    .getAccountMulti({ source: "USER" })
    .then((results) => results.toArray());
  return accounts;
}

/**
 * Get all accounts filtered using predicates
 * @function getAllAccounts
 * @param {Array.function} filter
 * @returns {Array.Account}
 */
export async function getAllAccounts(filter) {
  const accounts = await accountStore
    .getAccountMulti(filter)
    .then((results) => results.toArray());
  return accounts;
}

/*
We assume here that the user is restricted from typing any non-number or decimal values into the initial balance field.
This is a hard lock out on the view layer. So the initial balance is always a string.
 */
/**
 * Internal Method to validate input
 * @function validateNewAccount
 * @param {Account} account
 */
function validateNewAccount(passedInfo) {
  if (
    typeof passedInfo.name === "string" &amp;&amp;
    passedInfo.name !== "" &amp;&amp;
    passedInfo.initial_balance !== "" &amp;&amp;
    Number(passedInfo.initial_balance) >= 0 &amp;&amp;
    Number(passedInfo.initial_balance) ===
      Number(passedInfo.initial_balance).toFixed(2)
  ) {
    // If this returns true then the form was filled correctly and we can our data to the database and get the account's ID.
  }
  if (passedInfo.name === "") {
    throw new MissingFieldError("Account Name");
  }
  if (passedInfo.initial_balance === "") {
    throw new MissingFieldError("Initial Balance");
  }
  if (typeof passedInfo.name !== "string") {
    throw new FormattingError("Account Name");
  }
  if (
    typeof passedInfo.name !== "string" ||
    passedInfo.name === "" ||
    passedInfo.initial_balance === ""
  ) {
    throw new InvalidAmountError("Initial Balance");
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-domain_account.html">domain/account</a></li><li><a href="module-domain_exceptions.html">domain/exceptions</a></li><li><a href="module-domain_record.html">domain/record</a></li></ul><h3>Classes</h3><ul><li><a href="module-domain_exceptions-FormattingError.html">FormattingError</a></li><li><a href="module-domain_exceptions-InvalidAmountError.html">InvalidAmountError</a></li><li><a href="module-domain_exceptions-MissingFieldError.html">MissingFieldError</a></li><li><a href="module-domain_exceptions-ValidationError.html">ValidationError</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.0</a> on Fri Nov 25 2022 11:44:30 GMT-0800 (Pacific Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
